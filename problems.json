[
    {
        "title": "Two Sum",
        "statement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
        "solution": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]),i};    \n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}",
        "tags": [
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": "2025-10-04",
        "next_review": "2025-10-05",
        "review_count": 1,
        "success_count": 1,
        "ef": 2.6,
        "interval": 1
    },
    {
        "title": "Merge Two Sorted Lists",
        "statement": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]",
        "solution": "class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode ptr1 = list1;\n        ListNode ptr2 = list2;\n        ListNode head = null;\n        if(ptr1==null){return ptr2;}\n        if(ptr2==null){return ptr1;}\n        while(ptr1 != null && ptr2 != null){\n            if(ptr1.val <= ptr2.val){\n                if(head==null){head = ptr1;}\n                ListNode p = ptr1;\n                while(p.next!=null && p.next.val<=ptr2.val){p = p.next;}\n                ptr1 = p;\n                ListNode temp = ptr1.next;\n                ptr1.next = ptr2;\n                ptr1 = temp;\n            }else{\n                if(head==null){head = ptr2;}\n                ListNode p = ptr2;\n                while(p.next!=null && p.next.val<=ptr1.val){p = p.next;}\n                ptr2 = p;\n                ListNode temp = ptr2.next;\n                ptr2.next = ptr1;\n                ptr2 = temp;\n            }\n        }\n        return head;\n    }\n}",
        "tags": [
            "two pointers",
            "linkedlist",
            "recursion"
        ],
        "notes": "Recursive solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Squares of a Sorted Array",
        "statement": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\n \n\nExample 1:\n\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\nExample 2:\n\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]",
        "solution": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int minus=-1 , plus = 0 ,n=nums.length ,k=0;\n        int[] res = new int[n];\n        for(minus=-1;minus<n-1;minus++){\n            if(nums[minus+1]<0){\n                continue;\n            }else{\n                break;\n            }\n        }\n        plus=minus+1;\n        while(minus>=0 && plus<n){\n            int left = (int)Math.pow(nums[minus],2);\n            int right = (int)Math.pow(nums[plus],2);\n            if(left<=right){\n                res[k++] = left;\n                minus--;\n            }else{\n                res[k++] = right;\n                plus++;\n            }\n        }\n        while(minus>=0){\n            res[k++] = (int)Math.pow(nums[minus--],2);\n        }\n        while(plus<n){\n            res[k++] = (int)Math.pow(nums[plus++],2);\n        }\n        return res;\n    }\n}",
        "tags": [
            "two pointers",
            "array",
            "sorting"
        ],
        "notes": "the backward solution is easier",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Move Zeroes",
        "statement": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n \n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [0]",
        "solution": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int zero = 0;\n        for(int i = 0;i<nums.length;i++){\n            if(nums[i]!=0){\n                nums[zero++] = nums[i];\n            }\n        }\n        for(int i = zero;i<nums.length;i++){\n            nums[i] = 0;\n        }\n    }\n}",
        "tags": [
            "array",
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find the Duplicate Number",
        "statement": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and using only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\nExample 3:\n\nInput: nums = [3,3,3,3,3]\nOutput: 3",
        "solution": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0 , fast = 0;\n        while(true){\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if(slow == fast){\n                break;\n            }\n        }\n        fast = 0;\n        while(true){\n            slow=nums[slow];\n            fast=nums[fast];\n            if(slow==fast){\n                break;\n            }\n        }\n        return slow;\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "binary search",
            "bit manipulation"
        ],
        "notes": "study the hare and the turtle solution",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Merge Sorted Array",
        "statement": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.",
        "solution": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int ptrS = m, ptr2 = 0;\n        int curr = 0;\n        while (curr < ptrS && ptr2 < n) {\n            if (nums1[curr] <= nums2[ptr2]) {\n                curr++;\n            } else if (nums1[curr] > nums2[ptr2]) {\n                int i = ptrS - 1;\n                ptrS++;\n                while (i >= curr) {\n                    nums1[i + 1] = nums1[i];\n                    i--;\n                }\n                nums1[curr++] = nums2[ptr2++];\n            }\n        }\n        while (ptr2 < n) {\n            nums1[curr++] = nums2[ptr2++];\n        }\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "sorting"
        ],
        "notes": "look for bit manipulation solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Two Sum II - Input Array Is Sorted",
        "statement": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\n \n\nExample 1:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nExample 2:\n\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n\nExample 3:\n\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].",
        "solution": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int start = 0, end = numbers.length-1;\n        while(start<end){\n            int sum = numbers[start] + numbers[end];\n            if(sum==target){\n                return new int[]{start+1,end+1};\n            }else if(sum<target){\n                start++;\n            }else{\n                end--;\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "binary search"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Container With Most Water",
        "statement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1",
        "solution": "class Solution {\n    public int maxArea(int[] height) {\n        int start = 0 , end = height.length-1 , max = 0;\n        while(start<end){\n            int h = (height[start]<height[end])?height[start]:height[end];\n            int l = end-start;\n            int area = h*l;\n            max = Math.max(area,max);\n            if(height[start]<=height[end]){\n                start++;\n            }else{\n                end--;\n            }\n        }\n        return max;\n    }\n}",
        "tags": [
            "two pointers",
            "array",
            "greedy"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "3Sum",
        "statement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.",
        "solution": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        int i , j , k;\n        for(i=0;i<nums.length-2;){\n            j=i+1;\n            k=nums.length-1;\n            while(j<k){\n                int sum = nums[i] + nums[j] + nums[k];\n                if(sum==0){\n                    result.add(new ArrayList<Integer>(Arrays.asList(nums[i],nums[j],nums[k])));\n                    j++;\n                    k--;\n                    while(j<k && nums[j]==nums[j-1]){j++;}\n                    while(j<k && nums[k]==nums[k+1]){k--;}\n                }else if(sum>0){\n                    k--;   \n                }else{\n                    j++;\n                }\n            }\n            i++;\n            while(i<nums.length-2 && nums[i]==nums[i-1]){i++;}\n        }\n        return result;\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "sorting"
        ],
        "notes": "look for other solution",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Trapping Rain Water",
        "statement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9",
        "solution": "class Solution {\n    public int trap(int[] height) {\n        int total = 0;\n        int left=1 , right=height.length-2 , leftMax=height[left-1] , rightMax = height[right+1];\n        while(left<=right){\n            if(rightMax<leftMax){\n                total+= Math.max(0,rightMax - height[right]);\n                rightMax = Math.max(height[right],rightMax);\n                right--;\n                \n            }else{\n                total+= Math.max(0,leftMax - height[left]);\n                leftMax = Math.max(height[left],leftMax);\n                left++;\n            }\n        }\n        return total;\n    }\n}",
        "tags": [
            "stack"
        ],
        "notes": "look for other solution - stack , etc",
        "difficulty": "Hard",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "First Missing Positive",
        "statement": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\n \n\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.",
        "solution": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        for(int i = 0 ; i < nums.length; i++){\n            while(nums[i]>0  && nums[i] < nums.length && nums[nums[i] - 1] != nums[i]){\n                int temp = nums[nums[i]-1];\n                nums[nums[i]-1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        for(int i = 0 ;i<nums.length;i++){\n            if(nums[i] != i+1){\n                return i+1;\n            }\n        }\n        return nums.length+1;\n    }\n}",
        "tags": [
            "array",
            "hash table"
        ],
        "notes": "look for circular sort",
        "difficulty": "Hard",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Majority Element",
        "statement": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\n\n \n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: 3\n\nExample 2:\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2",
        "solution": "class Solution {\n    public int majorityElement(int[] nums) {\n        int count = 1 , candidate = nums[0];\n        for(int i:nums){\n            if(candidate == i){\n                count++;\n            }else{\n                count--;\n                if(count==0){\n                    candidate=i;\n                    count=1;\n                }\n            }\n        }\n        return candidate;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "divide and conquer",
            "sorting",
            "counting"
        ],
        "notes": "study candidate algorithm and the second iteration of this problem",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Majority Element II",
        "statement": "Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times.\n\n \n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: [3]\n\nExample 2:\n\nInput: nums = [1]\nOutput: [1]\n\nExample 3:\n\nInput: nums = [1,2]\nOutput: [1,2]\n",
        "solution": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        List<Integer> list = new ArrayList<>();\n        int count=1, cand = nums[0];\n        int k = nums.length/3;\n        for(int i=1;i<nums.length;i++){\n            if(cand==nums[i]){\n                count++;\n            }else{\n                if(count>k){\n                    list.add(cand);\n                }\n                cand = nums[i];\n                count=1;\n            }\n        }\n        if(count>k){\n                    list.add(cand);\n        }\n        return list;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "sorting",
            "counting"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Ransom Note",
        "statement": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\n\nEach letter in magazine can only be used once in ransomNote.\n\n \n\nExample 1:\n\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\n\nExample 2:\n\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\n\nExample 3:\n\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true",
        "solution": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n\t\tif (ransomNote.length() > magazine.length()) return false;\n        int[] alphabets_counter = new int[26];\n        \n        for (char c : magazine.toCharArray())\n            alphabets_counter[c-'a']++;\n\n        for (char c : ransomNote.toCharArray()){\n            if (alphabets_counter[c-'a'] == 0) return false;\n            alphabets_counter[c-'a']--;\n        }\n        return true;\n    }\n}",
        "tags": [
            "hash table",
            "string",
            "counting"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Reordered Power of 2",
        "statement": "You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero.\n\nReturn true if and only if we can do this so that the resulting number is a power of two.\n\n \n\nExample 1:\n\nInput: n = 1\nOutput: true\n\nExample 2:\n\nInput: n = 10\nOutput: false",
        "solution": "class Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        def signature(x):\n            return \"\".join(sorted(str(x)))\n        \n        target_sig = signature(n)\n        for i in range(31):\n            if signature(1 << i) == target_sig:\n                return True\n        return False",
        "tags": [
            "hash table",
            "math",
            "sorting",
            "counting",
            "enumeration"
        ],
        "notes": "learn about the binary rep of powers of 2",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Letter Tile Possibilities",
        "statement": "You have n  tiles, where each tile has one letter tiles[i] printed on it.\n\nReturn the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.\n\n \n\nExample 1:\n\nInput: tiles = \"AAB\"\nOutput: 8\nExplanation: The possible sequences are \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\".\n\nExample 2:\n\nInput: tiles = \"AAABBC\"\nOutput: 188\n\nExample 3:\n\nInput: tiles = \"V\"\nOutput: 1",
        "solution": "class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        sequences = set()\n        used = [False] * len(tiles)\n\n        # Generate all possible sequences including empty string\n        self._generate_sequences(tiles, \"\", used, sequences)\n\n        # Subtract 1 to exclude empty string from count\n        return len(sequences) - 1\n\n    def _generate_sequences(\n        self, tiles: str, current: str, used: list, sequences: set\n    ) -> None:\n        sequences.add(current)\n\n        # Try adding each unused character to current sequence\n        for pos, char in enumerate(tiles):\n            if not used[pos]:\n                used[pos] = True\n                self._generate_sequences(tiles, current + char, used, sequences)\n                used[pos] = False",
        "tags": [
            "hash table",
            "string",
            "backtracking",
            "counting"
        ],
        "notes": "learn lmao",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Number of Good Pairs",
        "statement": "Given an array of integers nums, return the number of good pairs.\n\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1,1,3]\nOutput: 4\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: 6\nExplanation: Each pair in the array are good.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 0",
        "solution": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i+1;j<nums.length;j++){\n                if(nums[i]==nums[j]){\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "math",
            "counting"
        ],
        "notes": "look for optimised solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Check if One String Swap Can Make Strings Equal",
        "statement": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\n\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.\n\n \n\nExample 1:\n\nInput: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".\n\nExample 2:\n\nInput: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.\n\nExample 3:\n\nInput: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required.",
        "solution": "bool areAlmostEqual(char* s1, char* s2) {\n    int i,count=0,len = strlen(s1);\n    int change1 = -1,change2 = -1;\n    if(strcmp(s1,s2) == 0){\n        return true;\n    }\n    for(i=0;i<len;i++){\n        if(s1[i]!=s2[i]){\n            count++;\n            if(count == 1){\n                change1 = i;\n            }\n            else if(count == 2){\n                change2 = i;\n            }\n            else{\n                return false;\n            }\n        }\n    }\n    return count==2 && (s1[change1]==s2[change2] && s1[change2] == s2[change1]);\n}",
        "tags": [
            "hash table",
            "string",
            "counting"
        ],
        "notes": "look for better solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Divide Array Into Equal Pairs",
        "statement": "You are given an integer array nums consisting of 2 * n integers.\n\nYou need to divide nums into n pairs such that:\n\n    Each element belongs to exactly one pair.\n    The elements present in a pair are equal.\n\nReturn true if nums can be divided into n pairs, otherwise return false.\n\n \n\nExample 1:\n\nInput: nums = [3,2,3,2,2,2]\nOutput: true\nExplanation: \nThere are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: \nThere is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.",
        "solution": "class Solution {\n    public boolean divideArray(int[] nums) {\n        TreeMap<Integer,Integer> table = new TreeMap<>();\n        for(int num:nums){\n            if(table.get(num) != null){\n                table.put(num,table.get(num)+1);\n            }else{\n                table.put(num,1);\n            }\n        }\n        for(int idx:table.keySet()){\n            if(table.get(idx)%2!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "bit manipulation",
            "counting"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Count Elements With Maximum Frequency",
        "statement": "You are given an array nums consisting of positive integers.\n\nReturn the total frequencies of elements in nums such that those elements all have the maximum frequency.\n\nThe frequency of an element is the number of occurrences of that element in the array.\n\n \n\nExample 1:\n\nInput: nums = [1,2,2,3,1,4]\nOutput: 4\nExplanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.\nSo the number of elements in the array with maximum frequency is 4.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: 5\nExplanation: All elements of the array have a frequency of 1 which is the maximum.\nSo the number of elements in the array with maximum frequency is 5.",
        "solution": "class Solution {\n    public int maxFrequencyElements(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        \n        for(int i:nums){\n            map.put(i,map.getOrDefault(i,0)+1);\n        }\n        int fmax = map.values().stream().max(Integer::compare).get();\n        int count=0;\n        for(int i:map.keySet()){\n            if(map.get(i)==fmax){\n                count+=fmax;\n            }\n        }\n        return count;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "counting"
        ],
        "notes": "learn stream",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find Most Frequent Vowel and Consonant",
        "statement": "You are given a string s consisting of lowercase English letters ('a' to 'z').\n\nYour task is to:\n\n    Find the vowel (one of 'a', 'e', 'i', 'o', or 'u') with the maximum frequency.\n    Find the consonant (all other letters excluding vowels) with the maximum frequency.\n\nReturn the sum of the two frequencies.\n\nNote: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.\nThe frequency of a letter x is the number of times it occurs in the string.\n\n \n\nExample 1:\n\nInput: s = \"successes\"\n\nOutput: 6\n\nExplanation:\n\n    The vowels are: 'u' (frequency 1), 'e' (frequency 2). The maximum frequency is 2.\n    The consonants are: 's' (frequency 4), 'c' (frequency 2). The maximum frequency is 4.\n    The output is 2 + 4 = 6.\n\nExample 2:\n\nInput: s = \"aeiaeia\"\n\nOutput: 3\n\nExplanation:\n\n    The vowels are: 'a' (frequency 3), 'e' ( frequency 2), 'i' (frequency 2). The maximum frequency is 3.\n    There are no consonants in s. Hence, maximum consonant frequency = 0.\n    The output is 3 + 0 = 3.\n\n",
        "solution": "class Solution {\n    public int maxFreqSum(String s) {\n        int []freq = new int[26];\n        for(char c:s.toCharArray()){\n            freq[c-'a'] += 1;\n        }\n        int mv = 0 , mc=0;\n        for(int i=0;i<26;i++){\n            if(i==0||i==4||i==8||i==14||i==20){\n                mv = Math.max(mv,freq[i]);\n            }else{\n                mc = Math.max(mc,freq[i]);\n            }\n        }\n        return mv+mc;\n    }\n}",
        "tags": [
            "hash table",
            "string",
            "counting"
        ],
        "notes": "look for better solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "4Sum",
        "statement": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n    0 <= a, b, c, d < n\n    a, b, c, and d are distinct.\n    nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n",
        "solution": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        for (int a = 0; a < nums.length - 1; a++) {\n            long t = target - nums[a];\n            for (int b = a + 1; b < nums.length - 2; b++) {\n                long tt = t - nums[b];\n                int c = b + 1, d = nums.length - 1;\n                while (c < d) {\n                    long sum = nums[c] + nums[d];\n                    if (sum == tt) {\n                        List<Integer> tem = Arrays.asList(nums[a], nums[b], nums[c], nums[d]);\n                        if (result.contains(tem)) {\n                            c++;\n                            continue;\n                        }\n                        result.add(tem);\n                        c++;\n                        continue;\n                    } else if (sum < tt) {\n                        c++;\n                    } else {\n                        d--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "sorting"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Remove Duplicates from Sorted Array",
        "statement": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\n    Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n    Return k.\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n",
        "solution": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int last = 0,k=1;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i]!=nums[last]){\n                nums[++last]=nums[i];\n                k+=1;\n            }\n        }\n        return k;\n    }\n}",
        "tags": [
            "array",
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Valid Palindrome",
        "statement": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\n \n\nExample 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\n\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n",
        "solution": "class Solution {\n    public boolean isPalindrome(String s) {\n        if(s.length()<=1){\n            return true;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(char c:s.toCharArray()){\n            if(Character.isLetterOrDigit(c)){\n                sb.append(Character.toLowerCase(c));\n            }\n        }\n        \n        for(int i=0,j=sb.length()-1;i<sb.length();i++){\n            if(sb.charAt(i)!=sb.charAt(j)){\n                return false;\n            }\n            j--;\n        }\n        return true;\n    }\n}",
        "tags": [
            "two pointers",
            "string"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Rotate Array",
        "statement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n \n\nConstraints:\n\n    1 <= nums.length <= 105\n    -231 <= nums[i] <= 231 - 1\n    0 <= k <= 105\n\n \n\nFollow up:\n\n    Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.\n    Could you do it in-place with O(1) extra space?\n",
        "solution": "class Solution {\n    public static void reverse(int[]nums,int start,int end){\n        while(start < end){\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n    public void rotate(int[] nums, int k) {\n        if(k==0) return;\n        int n = nums.length;\n        k%=n;\n        reverse(nums,0,n-1);\n        reverse(nums,0,k-1);\n        reverse(nums,k,n-1);\n    }\n}",
        "tags": [
            "array",
            "math",
            "two pointers"
        ],
        "notes": "learn for anti clock wise",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Swapping Nodes in a Linked List",
        "statement": "You are given the head of a linked list, and an integer k.\n\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\n\n \n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5\nOutput: [7,9,6,6,8,7,3,0,9,5]",
        "solution": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapNodes(struct ListNode* head, int k) {\n   if (!head) return NULL;\n\n    struct ListNode *first = head, *second = head, *current = head;\n    int length = 0;\n\n    while (current) {\n        length++;\n        current = current->next;\n    }\n   \n    for (int i = 1; i < k; i++) {\n        first = first->next;\n    }\n\n    \n    for (int i = 1; i <= length - k; i++) {\n        second = second->next;\n    }\n\n   \n    int temp = first->val;\n    first->val = second->val;\n    second->val = temp;\n\n    return head;\n}",
        "tags": [
            "linkedlist",
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Check If N and Its Double Exist",
        "statement": "Given an array arr of integers, check if there exist two indices i and j such that :\n\n    i != j\n    0 <= i, j < arr.length\n    arr[i] == 2 * arr[j]\n\n \n\nExample 1:\n\nInput: arr = [10,2,5,3]\nOutput: true\nExplanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\n\nExample 2:\n\nInput: arr = [3,1,7,11]\nOutput: false\nExplanation: There is no i and j that satisfy the conditions.\n",
        "solution": "class Solution:\n    def checkIfExist(self, arr: List[int]) -> bool:\n        seen = set()\n        zero_count = 0\n\n        for num in arr:\n            if num == 0:\n                zero_count += 1\n                if zero_count >= 2:\n                    return True\n            elif num * 2 in seen or (num % 2 == 0 and num // 2 in seen):\n                return True\n            seen.add(num)\n        \n        return False",
        "tags": [
            "array",
            "hash table",
            "two pointers",
            "binary search",
            "sorting"
        ],
        "notes": "look for other solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Duplicate Zeros",
        "statement": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\nNote that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n\n \n\nExample 1:\n\nInput: arr = [1,0,2,3,0,4,5,0]\nOutput: [1,0,0,2,3,0,0,4]\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nExample 2:\n\nInput: arr = [1,2,3]\nOutput: [1,2,3]\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n",
        "solution": "/**\n * @param {number[]} arr\n * @return {void} Do not return anything, modify arr in-place instead.\n */\nvar duplicateZeros = function(arr) {\n    new_arr = arr.reduce((ar,item)=>{\n        if(item == 0){\n            ar.push(item)\n            ar.push(0)\n        }else{\n            ar.push(item)    \n        }\n        return ar\n    },[])\n    \n    for(i = 0;i<arr.length;i++){\n        arr[i]=new_arr[i]\n    }\n};",
        "tags": [
            "array",
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": "2025-10-05",
        "next_review": "2025-10-06",
        "review_count": 1,
        "success_count": 1,
        "ef": 2.6,
        "interval": 1
    },
    {
        "title": "GOG - Find triplets with zero sum",
        "statement": "Given an array arr[] of integers, determine whether it contains a triplet whose sum equals zero. Return true if such a triplet exists, otherwise, return false.\n\nExamples:\n\nInput: arr[] = [0, -1, 2, -3, 1]\nOutput: true\nExplanation: The triplet [0, -1, 1] has a sum equal to zero.\n\nInput: arr[] = [1, 2, 3]\nOutput: false\nExplanation: No triplet with a sum of zero exists.\n\nInput: arr[] = [-5, 3, 2, -1, 0, 1]\nOutput: true\nExplanation: The triplet [-5, 3, 2] has a sum equal to zero.",
        "solution": "class Solution {\n    public boolean findTriplets(int[] arr) {\n        Arrays.sort(arr);\n        for (int fir = 0; fir < arr.length - 3; fir++) {\n            int val = arr[fir];\n            int start = fir + 1, end = arr.length - 1;\n            while (start < end) {\n                int sum = val + arr[start] + arr[end];\n                if (sum == 0) {\n                    return true;\n                } else if (sum > 0) {\n                    end--;\n                } else {\n                    start++;\n                }\n            }\n        }\n\n        return false;\n    }\n}",
        "tags": [
            "two pointers",
            "array",
            "searching",
            "sorting",
            "hash table"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Triplet Sum in Array",
        "statement": "Given an array arr[] and an integer target, determine if there exists a triplet in the array whose sum equals the given target.\n\nReturn true if such a triplet exists, otherwise, return false.\n\nExamples: \n\nInput: arr[] = [1, 4, 45, 6, 10, 8], target = 13\nOutput: true \nExplanation: The triplet {1, 4, 8} sums up to 13.\n\nInput: arr[] = [1, 2, 4, 3, 6, 7], target = 10\nOutput: true \nExplanation: The triplets {1, 3, 6} and {1, 2, 7} both sum to 10. \n\nInput: arr[] = [40, 20, 10, 3, 6, 7], target = 24\nOutput: false \nExplanation: No triplet in the array sums to 24.",
        "solution": "class Solution {\n    public boolean hasTripletSum(int arr[], int target) {\n        Arrays.sort(arr);\n        for (int i = 0;i < arr.length;i++) {\n            int start = i+1, end = arr.length - 1;\n            int tar = target - arr[i];\n            while (start < end) {\n                int sum = arr[start] + arr[end];\n                if (tar == sum) {\n                    return true;\n                } else if (sum < tar) {\n                    start++;\n                } else if (sum > tar) {\n                    end--;\n                }\n            }\n        }\n        return false;\n    }   \n}",
        "tags": [
            "two pointers",
            "array",
            "hash table",
            "sorting"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Find Last Digit Of a^b for Large Numbers",
        "statement": "You are given two integer numbers in the form of string, the base a and the index b. You have to find the last digit of ab.\n\nExamples:\n\nInput: a = \"3\", b = \"10\"\nOutput: 9\nExplanation: 310 = 59049. Last digit is 9.\n\nInput: a = \"6\", b = \"2\"\nOutput: 6\nExplanation: 62 = 36. Last digit is 6.\n\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function getLastDigit() which takes two strings a,b as parameters and returns an integer denoting the last digit of ab.",
        "solution": "class Solution {\n    static int getLastDigit(String a, String b) {\n        int a1 = a.charAt(a.length() - 1) - '0';\n\n        // Handle when exponent is 0\n        if (b.equals(\"0\")) return 1;\n\n        int op = 0;\n        switch (a1) {\n            case 0: case 1: case 5: case 6:\n                op = a1;\n                break;\n\n            case 4: case 9:\n                int lastDigitB = b.charAt(b.length() - 1) - '0';\n                if (lastDigitB % 2 == 0) {\n                    op = (a1 == 4) ? 6 : 1;\n                } else {\n                    op = a1;\n                }\n                break;\n\n            case 2: case 3: case 7: case 8:\n                // Get last 2 digits of b for modulo 4\n                int lastTwo = (b.length() >= 2) \n                    ? Integer.parseInt(b.substring(b.length() - 2))\n                    : Integer.parseInt(b);\n                int rem = lastTwo % 4;\n                if (rem == 0) rem = 4;\n                int res = (int) Math.pow(a1, rem);\n                op = res % 10;\n                break;\n        }\n        return op;\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "learn a simple method",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Power of Numbers",
        "statement": "Given a number n, find the value of n raised to the power of its own reverse.\nNote: The result will always fit into a 32-bit signed integer.\n\nExamples:\n\nInput: n = 2\nOutput: 4\nExplanation: The reverse of 2 is 2, and 22 = 4.\n\nInput: n = 10\nOutput: 10\nExplanation: The reverse of 10 is 1 (leading zero is discarded), and 10 raised to the power 1 is 10.",
        "solution": "class Solution {\n    public int reverseExponentiation(int n) {\n        int rev=0,rem=0,temp=n;\n        while(n>0){\n            rem=n%10;\n            rev = rev* 10 + rem;\n            n/=10;\n        }\n        return (int)Math.pow(temp,rev);\n    }\n}",
        "tags": [
            "math",
            "recursion",
            "divide and conquer"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Sort 0s, 1s and 2s",
        "statement": "Given an array arr[] containing only 0s, 1s, and 2s. Sort the array in ascending order.\nNote: You need to solve this problem without utilizing the built-in sort function.\n\nExamples:\n\nInput: arr[] = [0, 1, 2, 0, 1, 2]\nOutput: [0, 0, 1, 1, 2, 2]\nExplanation: 0s, 1s and 2s are segregated into ascending order.\n\nInput: arr[] = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]\nOutput: [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\nExplanation: 0s, 1s and 2s are segregated into ascending order.\n\nFollow up: Could you come up with a one-pass algorithm using only constant extra space?",
        "solution": "class Solution {\n    public void sort012(int[] arr) {\n        // code here\n        int low = 0 , mid =0, high = arr.length-1;\n        while(mid<=high){\n            if(arr[mid] == 0){\n                arr[mid++] = arr[low];\n                arr[low++] = 0;\n            }else if(arr[mid] == 1){\n                mid++;\n            }else if(arr[mid] == 2){\n                arr[mid] = arr[high];\n                arr[high--] = 2;\n            }\n        }\n    }\n}",
        "tags": [
            "array",
            "sorting"
        ],
        "notes": "learn dutch flag algorithm",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - K-th element of two Arrays",
        "statement": "Given two sorted arrays a[] and b[] and an element k, the task is to find the element that would be at the kth position of the combined sorted array.\n\nExamples :\n\nInput: a[] = [2, 3, 6, 7, 9], b[] = [1, 4, 8, 10], k = 5\nOutput: 6\nExplanation: The final combined sorted array would be [1, 2, 3, 4, 6, 7, 8, 9, 10]. The 5th element of this array is 6.\n\nInput: a[] = [1, 4, 8, 10, 12], b[] = [5, 7, 11, 15, 17], k = 6\nOutput: 10\nExplanation: Combined sorted array is [1, 4, 5, 7, 8, 10, 11, 12, 15, 17]. The 6th element of this array is 10.",
        "solution": "import java.util.*;\n\npublic class tUf {\n    public static int kthElement(ArrayList<Integer> a, ArrayList<Integer> b, int m, int n, int k) {\n        if (m > n) return kthElement(b, a, n, m, k);\n\n        int left = k; // length of left half\n\n        // apply binary search:\n        int low = Math.max(0, k - n), high = Math.min(k, m);\n        while (low <= high) {\n            int mid1 = (low + high) >> 1;\n            int mid2 = left - mid1;\n            // calculate l1, l2, r1, and r2\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE;\n            int r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\n            if (mid1 < m) r1 = a.get(mid1);\n            if (mid2 < n) r2 = b.get(mid2);\n            if (mid1 - 1 >= 0) l1 = a.get(mid1 - 1);\n            if (mid2 - 1 >= 0) l2 = b.get(mid2 - 1);\n\n            if (l1 <= r2 && l2 <= r1) {\n                return Math.max(l1, l2);\n            }\n\n            // eliminate the halves:\n            else if (l1 > r2) high = mid1 - 1;\n            else low = mid1 + 1;\n        }\n        return 0; // dummy statement\n    }\n}",
        "tags": [
            "array",
            "divide and conquer",
            "binary search"
        ],
        "notes": "look at the many solution for this problem",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Square Root",
        "statement": "Given a positive integer n, find the square root of n. If n is not a perfect square, then return the floor value.\n\nFloor value of any number is the greatest Integer which is less than or equal to that number.\n\nExamples:\n\nInput: n = 4\nOutput: 2\nExplanation: Since, 4 is a perfect square, so its square root is 2.\n\nInput: n = 11\nOutput: 3\nExplanation: Since, 11 is not a perfect square, floor of square root of 11 is 3.\n\nInput: n = 1\nOutput: 1\nExplanation: 1 is a perfect sqaure, so its square root is 1.",
        "solution": "class Solution {\n    int floorSqrt(int n) {\n        double newval , currval = 1;\n        if(n < 0){\n            return 0;\n        }\n        while(true){\n            newval = 0.5 * (currval + (n/currval));\n            if(newval == currval){\n                break;\n            }\n            currval=newval;\n        }\n        return (int)Math.floor(newval);\n    }\n}",
        "tags": [
            "math",
            "binary search",
            "searching"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Third largest element",
        "statement": "Given an array, arr of positive integers. Find the third largest element in it. Return -1 if the third largest element is not found.\n\nExamples:\n\nInput: arr[] = [2, 4, 1, 3, 5]\nOutput: 3\nExplanation: The third largest element in the array [2, 4, 1, 3, 5] is 3.\n\nInput: arr[] = [10, 2]\nOutput: -1\nExplanation: There are less than three elements in the array, so the third largest element cannot be determined.\n\nInput: arr[] = [5, 5, 5]\nOutput: 5\nExplanation: In the array [5, 5, 5], the third largest element can be considered 5, as there are no other distinct elements.",
        "solution": "class Solution {\n    int thirdLargest(int arr[]) {\n        // Your code here\n        PriorityQueue<Integer>  pq = new PriorityQueue<>();\n        for(int ele:arr){\n            pq.add(ele);\n            if(pq.size() > 3){\n                pq.poll();\n            }\n        }\n        return pq.peek();\n    }\n}",
        "tags": [
            "array"
        ],
        "notes": "look at different solutions",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Union of Arrays with Duplicates",
        "statement": "You are given two arrays a[] and b[], return the Union of both the arrays in any order.\n\nThe Union of two arrays is a collection of all distinct elements present in either of the arrays. If an element appears more than once in one or both arrays, it should be included only once in the result.\n\nNote: Elements of a[] and b[] are not necessarily distinct.\nNote that, You can return the Union in any order but the driver code will print the result in sorted order only.\n\nExamples:\n\nInput: a[] = [1, 2, 3, 2, 1], b[] = [3, 2, 2, 3, 3, 2]\nOutput: [1, 2, 3]\nExplanation: Union set of both the arrays will be 1, 2 and 3.\n\nInput: a[] = [1, 2, 3], b[] = [4, 5, 6] \nOutput: [1, 2, 3, 4, 5, 6]\nExplanation: Union set of both the arrays will be 1, 2, 3, 4, 5 and 6.\n\nInput: a[] = [1, 2, 1, 1, 2], b[] = [2, 2, 1, 2, 1] \nOutput: [1, 2]\nExplanation: Union set of both the arrays will be 1 and 2.",
        "solution": "class TUF{\nstatic ArrayList<Integer> FindUnion(int arr1[], int arr2[], int n, int m) {\n   int i = 0, j = 0; // pointers\n  ArrayList<Integer > Union=new ArrayList<>(); // Uninon vector\n  while (i < n && j < m) {\n    if (arr1[i] <= arr2[j]) // Case 1 and 2\n    {\n      if (Union.size() == 0 || Union.get(Union.size()-1) != arr1[i])\n        Union.add(arr1[i]);\n      i++;\n    } else // case 3\n    {\n      if (Union.size() == 0 || Union.get(Union.size()-1) != arr2[j])\n        Union.add(arr2[j]);\n      j++;\n    }\n  }\n  while (i < n) // IF any element left in arr1\n  {\n    if (Union.get(Union.size()-1) != arr1[i])\n      Union.add(arr1[i]);\n    i++;\n  }\n  while (j < m) // If any elements left in arr2\n  {\n    if (Union.get(Union.size()-1) != arr2[j])\n      Union.add(arr2[j]);\n    j++;\n  }\n  return Union;\n}",
        "tags": [
            "hash table",
            "array",
            "two pointers"
        ],
        "notes": "look at other solutions",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Missing in Array",
        "statement": "You are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\n\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.",
        "solution": "class Solution {\n    int missingNum(int arr[]) {\n        // int sum =0;\n        // int n = arr.length+1;\n        // int exp = (n*(n+1))/2;\n        // for(int i : arr){\n        //     exp-=i;\n        // }\n        \n        // return exp;\n        long n = arr.length + 1;\n    \n        // Calculate the sum of array elements\n        long sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n    \n        // Use long for expected sum to avoid overflow\n        long expSum = n * (n + 1) / 2;\n    \n        // Return the missing number\n        return (int)(expSum - sum);\n    }\n}",
        "tags": [
            "array",
            "searching",
            "bit manipulation"
        ],
        "notes": "learn other solutions like xor",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Missing And Repeating",
        "statement": "Given an unsorted array arr[] of size n, containing elements from the range 1 to n, it is known that one number in this range is missing, and another number occurs twice in the array, find both the duplicate number and the missing number.\n\nExamples:\n\nInput: arr[] = [2, 2]\nOutput: [2, 1]\nExplanation: Repeating number is 2 and the missing number is 1.\n\nInput: arr[] = [1, 3, 3] \nOutput: [3, 2]\nExplanation: Repeating number is 3 and the missing number is 2.\n\nInput: arr[] = [4, 3, 6, 2, 1, 1]\nOutput: [1, 5]\nExplanation: Repeating number is 1 and the missing number is 5.",
        "solution": "class Solution {\n    ArrayList<Integer> findTwoElement(int arr[]) {\n        // code here\n        int dup=0 , miss;\n        int [] map = new int[arr.length];\n        long sum = 0;\n        for(int i:arr){\n            map[i-1]+=1;\n            sum += i;\n            if(map[i-1]==2){\n                dup = i;\n                sum-=i;\n            }\n        }\n        long n = arr.length;\n        long exp = (n * (n+1))/2;\n        miss = (int)(exp - sum);\n        return new ArrayList<>(Arrays.asList(dup, miss));\n    }\n}",
        "tags": [
            "array",
            "math"
        ],
        "notes": "learn other solutions",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Two Sum - Pair with Given Sum",
        "statement": "Given an array arr[] of integers and another integer target. Determine if there exist two distinct indices such that the sum of their elements is equal to the target.\n\nExamples:\n\nInput: arr[] = [0, -1, 2, -3, 1], target = -2\nOutput: true\nExplanation: arr[3] + arr[4] = -3 + 1 = -2\n\nInput: arr[] = [1, -2, 1, 0, 5], target = 0\nOutput: false\nExplanation: None of the pair makes a sum of 0\n\nInput: arr[] = [11], target = 11\nOutput: false\nExplanation: No pair is possible as only one element is present in arr[]",
        "solution": "class Solution {\n    boolean twoSum(int arr[], int target) {\n        Arrays.sort(arr);\n        int start=0 , end = arr.length-1;\n        while(start<end){\n            int sum = arr[start] + arr[end];\n            if(sum==target){\n                return true;\n            }else if(sum<target){\n                start++;\n            }else{\n                end--;\n            }\n        }\n        return false;\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "hash table"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Remove Duplicates Sorted Array",
        "statement": "You are given a sorted array arr[] containing positive integers. Your task is to remove all duplicate elements from this array such that each element appears only once. Return an array containing these distinct elements in the same order as they appeared.\nExamples :\n\nInput: arr[] = [2, 2, 2, 2, 2]\nOutput: [2]\nExplanation: After removing all the duplicates only one instance of 2 will remain i.e. [2] so modified array will contains 2 at first position and you should return array containing [2] after modifying the array.\n\nInput: arr[] = [1, 2, 4]\nOutput: [1, 2, 4]\nExplation:  As the array does not contain any duplicates so you should return [1, 2, 4].",
        "solution": "class Solution {\n    // Function to remove duplicates from the given array.\n    ArrayList<Integer> removeDuplicates(int[] arr) {\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(arr[0]);\n        for(int i=1;i<arr.length;i++){\n            if(arr[i]!=list.get(list.size()-1)){\n                list.add(arr[i]);\n            }\n        }\n        return list;\n    }   \n}",
        "tags": [
            "two pointers",
            "array"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Frequencies in a Limited Array",
        "statement": "You are given an array arr[] containing positive integers. The elements in the array arr[] range from  1 to n (where n is the size of the array), and some numbers may be repeated or absent. Your have to count the frequency of all numbers in the range 1 to n and return an array of size n such that result[i] represents the frequency of the number i (1-based indexing).\n\nExamples:\n\nInput: arr[] = [2, 3, 2, 3, 5]\nOutput: [0, 2, 2, 0, 1]\nExplanation: We have: 1 occurring 0 times, 2 occurring 2 times, 3 occurring 2 times, 4 occurring 0 times, and 5 occurring 1 time.\n\nInput: arr[] = [3, 3, 3, 3]\nOutput: [0, 0, 4, 0]\nExplanation: We have: 1 occurring 0 times, 2 occurring 0 times, 3 occurring 4 times, and 4 occurring 0 times.\n\nInput: arr[] = [1]\nOutput: [1]\nExplanation: We have: 1 occurring 1 time, and there are no other numbers between 1 and the size of the array.",
        "solution": "class Solution {\n    public List<Integer> frequencyCount(int[] arr) {\n        // List<Integer> freq = new ArrayList<>();\n        // for(int i=0;i<arr.length;i++){\n        //     freq.add(0);\n        // }\n        // for(int val: arr){\n        //     freq.set(val-1,freq.get(val-1)+1);\n        // }\n        // return freq;\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        int n = arr.length;\n        for (int num : arr) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n\n        ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            result.add(freqMap.getOrDefault(i, 0));\n        }\n\n        return result;\n    }\n}",
        "tags": [
            "array",
            "hashmap"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Check Equal Arrays",
        "statement": "Given two arrays a[] and b[] of equal size, the task is to find whether the elements in the arrays are equal.\nTwo arrays are said to be equal if both contain the same set of elements, arrangements (or permutations) of elements may be different though.\nNote: If there are repetitions, then counts of repeated elements must also be the same for two arrays to be equal.\n\nExamples:\n\nInput: a[] = [1, 2, 5, 4, 0], b[] = [2, 4, 5, 0, 1]\nOutput: true\nExplanation: Both the array can be rearranged to [0,1,2,4,5]\n\nInput: a[] = [1, 2, 5], b[] = [2, 4, 15]\nOutput: false\nExplanation: a[] and b[] have only one common value.",
        "solution": "class GfG {\n\n    public static boolean checkEqual(int a[], int b[]) {\n        int n = a.length, m = b.length;\n        if (n != m)\n            return false;\n\n        Map<Integer, Integer> map\n            = new HashMap<Integer, Integer>();\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (map.get(a[i]) == null)\n                map.put(a[i], 1);\n            else {\n                count = map.get(a[i]);\n                count++;\n                map.put(a[i], count);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n\n            if (!map.containsKey(b[i]))\n                return false;\n\n            if (map.get(b[i]) == 0)\n                return false;\n\n            count = map.get(b[i]);\n            --count;\n            map.put(b[i], count);\n        }\n\n        return true;\n    }\n}",
        "tags": [
            "array",
            "hashtable",
            "sorting"
        ],
        "notes": "learn other approaches",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Intersection of Arrays with Distinct",
        "statement": "Given two unsorted integer arrays a[] and b[] each consisting of distinct elements, the task is to return the count of elements in the intersection (or common elements) of the two arrays.\n\nIntersection of two arrays can be defined as the set containing distinct common elements between the two arrays. \n\nExamples:\n\nInput: a[] = [89, 24, 75, 11, 23], b[] = [89, 2, 4]\nOutput: 1\nExplanation: 89 is the only element in the intersection of two arrays.\n\nInput: a[] = [1, 2, 4, 3, 5, 6], b[] = [3, 4, 5, 6, 7]\nOutput: 4\nExplanation: 3, 4, 5, and 6 are the elements in the intersection of two arrays.\n\nInput: a[] = [20, 10, 30, 50, 40], b[] = [15, 25, 30, 20, 35]\nOutput: 2\nExplanation: 20 and 30 are the elements in the intersection of the two arrays.\n",
        "solution": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> s = new HashSet<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int m = nums1.length;\n        int n = nums2.length;\n        int i = 0, j = 0;\n        while (i < m && j < n) {\n            if (nums1[i] == nums2[j]) {\n                s.add(nums1[i]);\n                i++;\n                j++;\n            } else if (nums1[i] > nums2[j]) {\n                j++;\n            } else {\n                i++;\n            }\n        }\n        int[] res = new int[s.size()];\n        int ctr = 0;\n        for (Integer num : s) {\n            res[ctr++] = num;\n        }\n        return res;\n    }\n}",
        "tags": [
            "array",
            "two pointers",
            "hashset"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG- Count the triplets",
        "statement": "\n\nGiven an array arr, count the number of distinct triplets (a, b, c) such that:\n\n    a + b = c\n\n    Each triplet is counted only once, regardless of the order of a and b.\n\nExamples:\n\nInput: arr[] = [1, 5, 3, 2]\nOutput: 2 \nExplanation: There are 2 triplets: 1 + 2 = 3 and 3 +2 = 5\n\nInput: arr[] = [2, 3, 4]\nOutput: 0\nExplanation: No such triplet exits",
        "solution": "class Solution {\n    int countTriplet(int arr[]) {\n        // code here\n        int n=arr.length;\n        int count=0;\n        Arrays.sort(arr);\n        for(int i=n-1;i>=2;i--){\n            long c=arr[i];\n            int left=0,right=i-1;\n            while(left<right){\n                long sum=(long)arr[left]+arr[right];\n                if(sum==c){\n                   count++;\n                   left++;\n                   right--;\n                }else if(sum<c){\n                    left++;\n                }else{\n                    right--;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "tags": [
            "sorting",
            "two pointers"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Armstrong Numbers",
        "statement": "You are given a 3-digit number n, Find whether it is an Armstrong number or not.\n\nAn Armstrong number of three digits is a number such that the sum of the cubes of its digits is equal to the number itself. 371 is an Armstrong number since 33 + 73 + 13 = 371. \n\nExamples:\n\nInput: n = 153\nOutput: true\nExplanation: 153 is an Armstrong number since 13 + 53 + 33 = 153. \n\nInput: n = 372\nOutput: false\nExplanation: 372 is not an Armstrong number since 33 + 73 + 23 = 378. \n\nInput: n = 100\nOutput: false\nExplanation: 100 is not an Armstrong number since 13 + 03 + 03 = 1. ",
        "solution": "// User function Template for Java\nclass Solution {\n    static boolean armstrongNumber(int n) {\n        int rev = 0 , temp = n , rem = 0;\n        while(n>0){\n            rem = n % 10;\n            rev += Math.pow(rem,3);\n            n/=10;\n        }\n        if(temp == rev){\n            return true;\n        }else{\n            return  false;\n        }\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Count Digits",
        "statement": "Given a positive integer n, count the number of digits in n that divide n evenly (i.e., without leaving a remainder). Return the total number of such digits.\n\n    A digit d of n divides n evenly if the remainder when n is divided by d is 0 (n % d == 0).\n    Digits of n should be checked individually. If a digit is 0, it should be ignored because division by 0 is undefined.\n\nExamples :\n\nInput: n = 12\nOutput: 2\nExplanation: 1, 2 when both divide 12 leaves remainder 0.\n\nInput: n = 2446\nOutput: 1\nExplanation: Here among 2, 4, 6 only 2 divides 2446 evenly while 4 and 6 do not.\n\nInput: n = 23\nOutput: 0\nExplanation: 2 and 3, none of them divide 23 evenly.\n",
        "solution": "// User function Template for Java\n\nclass Solution {\n    static int evenlyDivides(int n) {\n        int count =0;\n        ArrayList<Integer> digits = new ArrayList<>();\n        int temp = n;\n        while(temp>0){\n            digits.add(temp%10);\n            temp/=10;\n        }\n        for(int i:digits){\n            if(i==0){\n                continue;\n            }\n            if(n%i==0){ \n                count+=1;\n            }\n        }\n        return count;\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Perfect Numbers",
        "statement": "Given a number n, check if the number is perfect or not. A number is said to be perfect if sum of all its factors excluding the number itself is equal to the number.\n\nExamples:\n\nInput: n = 6\nOutput: true \nExplanation: Factors of 6 are 1, 2, 3 and 6. Excluding 6 their sum is 6 which is equal to n itself. So, it's a Perfect Number.\n\nInput: n = 10\nOutput: false\nExplanation: Factors of 10 are 1, 2, 5 and 10. Excluding 10 their sum is 8 which is not equal to n itself. So, it's not a Perfect Number.\n\nInput: n = 15\nOutput: false\nExplanation: Factors of 15 are 1, 3, 5, 15. Excluding 15 their sum is 9 which is not equal to n itself. So, it's not a Perfect Number.",
        "solution": "class Solution {\n    static boolean isPerfect(int n) {\n        // code here\n        int sum = 1;\n        for(int i = 2;i<=Math.sqrt(n);i++){\n            if(n%i==0){\n                sum+=i;\n                int other = n/i;\n                if(other!=i){\n                    sum+=other;\n                }\n            }\n        }\n        if(sum==n){\n            return true;\n        }else{\n            return false;\n        }\n    }\n};",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Array Search",
        "statement": "Given an array, arr[] of n integers, and an integer element x, find whether element x is present in the array. Return the index of the first occurrence of x in the array, or -1 if it doesn't exist.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 4], x = 3\nOutput: 2\nExplanation: For array [1, 2, 3, 4], the element to be searched is 3. Since 3 is present at index 2, the output is 2.\n\nInput: arr[] = [10, 8, 30, 4, 5], x = 5\nOutput: 4\nExplanation: For array [10, 8, 30, 4, 5], the element to be searched is 5 and it is at index 4. So, the output is 4.\n\nInput: arr[] = [10, 8, 30], x = 6\nOutput: -1\nExplanation: The element to be searched is 6 and it is not present, so we return -1.",
        "solution": "class Solution {\n    public int search(int arr[], int x) {\n        // int lo = 0 , hi = arr.length;\n        // int mid;\n        // Arrays.sort(arr);\n        // while(lo<hi){\n        //     mid = (lo+hi)/2;\n        //     if(arr[mid] == x){\n        //         return mid;\n        //     }else if(arr[mid]<x){\n        //         lo = mid + 1;\n        //     }else{\n        //         hi = mid - 1;\n        //     }\n        // }\n        // return -1;\n        int idx = 0;\n        for(idx = 0;idx<arr.length;idx++){\n            if(arr[idx] == x){\n                return idx;\n            }\n        }\n        return -1;\n    }\n}",
        "tags": [
            "array",
            "searching"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Array Subset",
        "statement": "Given two arrays a[] and b[], your task is to determine whether b[] is a subset of a[].\n\nExamples:\n\nInput: a[] = [11, 7, 1, 13, 21, 3, 7, 3], b[] = [11, 3, 7, 1, 7]\nOutput: true\nExplanation: b[] is a subset of a[]\n\nInput: a[] = [1, 2, 3, 4, 4, 5, 6], b[] = [1, 2, 4]\nOutput: true\nExplanation: b[] is a subset of a[]\n\nInput: a[] = [10, 5, 2, 23, 19], b[] = [19, 5, 3]\nOutput: false\nExplanation: b[] is not a subset of a[]",
        "solution": "class Solution {\n    public boolean isSubset(int a[], int b[]) {\n        // Your code here\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<a.length;i++){\n            if(map.containsKey(a[i])){\n                map.put(a[i],map.get(a[i])+1);\n            }else{\n                map.put(a[i],1);\n            }\n        }\n        for(int val:b){\n            if(map.containsKey(val) && map.get(val)>=1){\n                map.put(val,map.get(val)-1);\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": [
            "array",
            "searching",
            "binary search",
            "hashset"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - GCD of two numbers",
        "statement": "Given two positive integers a and b, find GCD of a and b.\n\nNote: Don't use the inbuilt gcd function\n\nExamples:\n\nInput: a = 20, b = 28\nOutput: 4\nExplanation: GCD of 20 and 28 is 4\n\nInput: a = 60, b = 36\nOutput: 12\nExplanation: GCD of 60 and 36 is 12",
        "solution": "class Solution {\n    public static int gcd(int a, int b) {\n        while(a!=b){\n            if(a>b){\n                a-=b;\n            }else if(b>a){\n                b-=a;\n            }\n        }\n        return a;\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "learn euclid's two methods",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG- Reverse digits",
        "statement": "You are given an integer n. Your task is to reverse the digits, ensuring that the reversed number has no leading zeroes.\n\nExamples:\n\nInput: n = 122\nOutput: 221\nExplanation: By reversing the digits of number, number will change into 221.\n\nInput : n = 200\nOutput: 2\nExplanation: By reversing the digits of number, number will change into 2.\n\nInput : n = 12345 \nOutput: 54321\nExplanation: By reversing the digits of number, number will change into 54321.",
        "solution": "class Solution {\n    public int reverseDigits(int n) {\n        // Code here\n        int rem=0,rev=0;\n        while(n>0){\n            rem = n % 10;\n            rev = rev * 10 + rem;\n            n /= 10; \n        }\n        return rev;\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Min and Max in Array",
        "statement": "Given an array arr[]. Your task is to find the minimum and maximum elements in the array.\n\nExamples:\n\nInput: arr[] = [1, 4, 3, -5, -4, 8, 6]\nOutput: [-5, 8]\nExplanation: minimum and maximum elements of array are -5 and 8.\n\nInput: arr[] = [12, 3, 15, 7, 9]\nOutput: [3, 15]\nExplanation: minimum and maximum element of array are 3 and 15.",
        "solution": "class Solution {\n    public Pair<Integer, Integer> getMinMax(int[] arr) {\n        // Code Here\n        int min = Integer.MAX_VALUE , max = Integer.MIN_VALUE;\n        for(int i = 0 ; i < arr.length ; i++){\n            min = Math.min(arr[i],min);\n            max = Math.max(arr[i],max);\n        }\n        return new Pair(min,max);\n    }\n}",
        "tags": [
            "array"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "GOG - Odd or Even",
        "statement": "Given a positive integer n, determine whether it is odd or even. Return true if the number is even and false if the number is odd.\n\nExamples:\n\nInput: n = 15\nOutput: false\nExplanation: The number is not divisible by 2, Odd number.\n\nInput: n = 44\nOutput: true\nExplanation: The number is divisible by 2, Even number.",
        "solution": "class Solution {\n    static boolean isEven(int n) {\n        // code here\n        return (n%2==0)?true:false;\n    }\n}",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Richest Customer Wealth",
        "statement": "You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b customer has in the j\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b bank. Return the wealth that the richest customer has.\n\nA customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.\n\n \n\nExample 1:\n\nInput: accounts = [[1,2,3],[3,2,1]]\nOutput: 6\nExplanation:\n1st customer has wealth = 1 + 2 + 3 = 6\n2nd customer has wealth = 3 + 2 + 1 = 6\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\nExample 2:\n\nInput: accounts = [[1,5],[7,3],[3,5]]\nOutput: 10\nExplanation: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\n\nExample 3:\n\nInput: accounts = [[2,8,7],[7,1,3],[1,9,5]]\nOutput: 17\n",
        "solution": "int maximumWealth(int** accounts, int accountsSize, int* accountsColSize) {\n    int max=0;\n    for(int i=0;i<accountsSize;i++)\n    {\n        int wealth=0;\n        for(int j=0;j<*accountsColSize;j++){\n            wealth=wealth+accounts[i][j];\n        }\n        if(wealth>max){\n            max=wealth;\n        }\n    }\n    return max;\n}",
        "tags": [
            "array",
            "matrix"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Insert Greatest Common Divisors in Linked List",
        "statement": "Given the head of a linked list head, in which each node contains an integer value.\n\nBetween every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.\n\nReturn the linked list after insertion.\n\nThe greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.\n\n Example 1:\nInput: head = [18,6,10,3]\nOutput: [18,6,6,2,10,1,3]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).\n- We insert the greatest common divisor of 18 and 6 = 6 between the 1st and the 2nd nodes.\n- We insert the greatest common divisor of 6 and 10 = 2 between the 2nd and the 3rd nodes.\n- We insert the greatest common divisor of 10 and 3 = 1 between the 3rd and the 4th nodes.\nThere are no more adjacent nodes, so we return the linked list.\nExample 2:\nInput: head = [7]\nOutput: [7]\nExplanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.\nThere are no pairs of adjacent nodes, so we return the initial linked list.\n",
        "solution": "/**\n * Definition for singly-linked list.\n * C\n */\n    \n\nint gcd(int a,int b){\n    int temp;\n    while(b != 0){\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nstruct ListNode* insertGreatestCommonDivisors(struct ListNode* head) {\n    struct ListNode* p = head;\n    struct ListNode* sec;\n    int val;\n    while(p->next != NULL){\n        sec = p->next;\n        val = gcd(p->val,sec->val);\n        struct ListNode* temp =(struct ListNode*)malloc(sizeof(struct ListNode));\n        temp->val = val;\n        temp->next = p->next;\n        p->next = temp; \n        p=sec;\n    }\n    return head;\n}",
        "tags": [
            "linkedlist",
            "math"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Minimum Number of Operations to Move All Balls to Each Box",
        "statement": "You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.\n\nIn one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.\n\nReturn an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.\n\nEach answer[i] is calculated considering the initial state of the boxes.\n\n \n\nExample 1:\n\nInput: boxes = \"110\"\nOutput: [1,1,3]\nExplanation: The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\nExample 2:\n\nInput: boxes = \"001011\"\nOutput: [11,8,5,4,3,4]",
        "solution": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* minOperations(char* boxes, int* returnSize) {\n    int i,j,n2,n1=strlen(boxes),pos[n1];\n    int* answer = (int *)malloc(sizeof(int) * n1);\n    for(i=0,j=0;i<n1;i++){\n        if(boxes[i]=='1'){\n            pos[j]=i;\n            j++;\n        }\n    }\n    *returnSize = n1;\n    n2 = j;\n    for(i=0;i<n1;i++){\n        int ans=0;\n        int val = boxes[i] - '0';\n        for(j=0;j<n2;j++){\n            ans += abs(i-pos[j]);\n        }\n        answer[i] = ans;\n    }\n    return answer;\n}",
        "tags": [
            "array",
            "string",
            "prefix sum"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
        "statement": "A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\n\nGiven a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n\n \n\nExample 1:\n\nInput: n = \"32\"\nOutput: 3\nExplanation: 10 + 11 + 11 = 32\n\nExample 2:\n\nInput: n = \"82734\"\nOutput: 8\n\nExample 3:\n\nInput: n = \"27346209830709182346\"\nOutput: 9",
        "solution": "int minPartitions(char* n) {\n    int max,i,j,size=strlen(n);\n    max = n[size-1] - '0';\n    for(i=size-2;i>=0;i--){\n        j = n[i] - '0';\n        if(max<j){\n            max = j;\n        }\n        else if(max == 9){\n            return max;\n        }\n    }\n    return max;\n}",
        "tags": [
            "string",
            "greedy"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Zigzag Conversion",
        "statement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n \n\nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"",
        "solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1: return s\n        a=\"\"\n        for i in range(numRows):\n            for j in range(i,len(s),2*(numRows-1)):\n                a+=s[j]\n                if(i>0 and i<numRows-1 and j+2*(numRows-1)-2*i < len(s)):\n                    a+=s[j+2*(numRows-1)-2*i]\n        return a",
        "tags": [
            "string"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Strictly Palindromic Number",
        "statement": "An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.\n\nGiven an integer n, return true if n is strictly palindromic and false otherwise.\n\nA string is palindromic if it reads the same forward and backward.\n\n \n\nExample 1:\n\nInput: n = 9\nOutput: false\nExplanation: In base 2: 9 = 1001 (base 2), which is palindromic.\nIn base 3: 9 = 100 (base 3), which is not palindromic.\nTherefore, 9 is not strictly palindromic so we return false.\nNote that in bases 4, 5, 6, and 7, n = 9 is also not palindromic.\n\nExample 2:\n\nInput: n = 4\nOutput: false\nExplanation: We only consider base 2: 4 = 100 (base 2), which is not palindromic.\nTherefore, we return false.\n",
        "solution": "bool isStrictlyPalindromic(int n) {\n    return false;\n}",
        "tags": [
            "math",
            "two pointers"
        ],
        "notes": "learn why this is true",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find the Number of Distinct Colors Among the Balls",
        "statement": "You are given an integer limit and a 2D array queries of size n x 2.\n\nThere are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of colors among the balls.\n\nReturn an array result of length n, where result[i] denotes the number of colors after ith query.\n\nNote that when answering a query, lack of a color will not be considered as a color.\n\n \n\nExample 1:\n\nInput: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n\nOutput: [1,2,2,3]\n\nExplanation:\n\n    After query 0, ball 1 has color 4.\n    After query 1, ball 1 has color 4, and ball 2 has color 5.\n    After query 2, ball 1 has color 3, and ball 2 has color 5.\n    After query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.\n\nExample 2:\n\nInput: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n\nOutput: [1,2,2,3,4]\n\nExplanation:\n\n    After query 0, ball 0 has color 1.\n    After query 1, ball 0 has color 1, and ball 1 has color 2.\n    After query 2, ball 0 has color 1, and balls 1 and 2 have color 2.\n    After query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.\n    After query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.\n",
        "solution": "class Solution {\n    public int[] queryResults(int limit, int[][] queries) {\n        Map<Integer,Integer> ball = new HashMap<>(), color = new HashMap<>();\n        int n = queries.length, distinct = 0;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++){\n            int pos = queries[i][0], c = queries[i][1];\n            if(ball.containsKey(pos)){\n                int cnt = color.get(ball.get(pos)) - 1;\n                if(cnt == 0){ color.remove(ball.get(pos)); distinct--; }\n                else color.put(ball.get(pos), cnt);\n            }\n            ball.put(pos, c);\n            int cnt = color.getOrDefault(c, 0) + 1;\n            color.put(c, cnt);\n            if(cnt == 1) distinct++;\n            ans[i] = distinct;\n        }\n        return ans;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "simulation"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Divide Two Integers",
        "statement": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n\nReturn the quotient after dividing dividend by divisor.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\n \n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n",
        "solution": "class Solution {\npublic:\n    \tint divide(int dividend, int divisor) {\n        if(dividend == divisor)\n            return 1;\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\n        unsigned int a = abs((long long)dividend);\n        unsigned int b = abs((long long)divisor);\n        unsigned int ans = 0;\n        while(a >= b){  // while dividend is greater than or equal to divisor\n            short q = 0;\n            while(a > (b<<(q+1)))\n                q++;\n            ans += (1<<q);  // add the power of 2 found to the answer\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\n        }\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\n            return INT_MAX;\n        return isPositive ? ans : -ans;\n    }\n};",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Jump Game",
        "statement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.",
        "solution": "bool canJump(int* nums, int numsSize) {\n    int i,cost=0;\n    for(i=numsSize-2;i>=0;i--){\n        cost++;\n        if(nums[i]>=cost){\n            cost=0;\n        }        \n    }\n    if(cost == 0 )\n    {\n        return true;\n    }\n    else{\n        return false;\n    }\n\n}",
        "tags": [
            "array",
            "dynamic programming",
            "greedy"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Remove All Occurrences of a Substring",
        "statement": "Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:\n\n    Find the leftmost occurrence of the substring part and remove it from s.\n\nReturn s after removing all occurrences of part.\n\nA substring is a contiguous sequence of characters in a string.\n\n \n\nExample 1:\n\nInput: s = \"daabcbaabcbc\", part = \"abc\"\nOutput: \"dab\"\nExplanation: The following operations are done:\n- s = \"daabcbaabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\".\n- s = \"dabaabcbc\", remove \"abc\" starting at index 4, so s = \"dababc\".\n- s = \"dababc\", remove \"abc\" starting at index 3, so s = \"dab\".\nNow s has no occurrences of \"abc\".\n\nExample 2:\n\nInput: s = \"axxxxyyyyb\", part = \"xy\"\nOutput: \"ab\"\nExplanation: The following operations are done:\n- s = \"axxxxyyyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\".\n- s = \"axxxyyyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\".\n- s = \"axxyyb\", remove \"xy\" starting at index 2 so s = \"axyb\".\n- s = \"axyb\", remove \"xy\" starting at index 1 so s = \"ab\".\nNow s has no occurrences of \"xy\".",
        "solution": "class Solution {\n    public String removeOccurrences(String s, String part) {\n        StringBuilder temp = new StringBuilder(s);\n        int idx,len=part.length();\n        idx=temp.indexOf(part);\n        while(idx!=-1){\n            temp.delete(idx,idx+len);\n            idx=temp.indexOf(part);\n        }\n        return temp.toString();\n    }\n}",
        "tags": [
            "string",
            "stack",
            "simulation"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Binary Search Tree to Greater Sum Tree",
        "statement": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\n\n    The left subtree of a node contains only nodes with keys less than the node's key.\n    The right subtree of a node contains only nodes with keys greater than the node's key.\n    Both the left and right subtrees must also be binary search trees.\n\n \n\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\nExample 2:\n\nInput: root = [0,null,1]\nOutput: [1,null,1]\n",
        "solution": "void reverseInorder(struct TreeNode* root,int* sum){\n    if(root){\n        reverseInorder(root->right,sum);\n        (*sum) = (*sum) + root->val;\n        root->val = (*sum);\n        reverseInorder(root->left,sum);\n    }\n}\nstruct TreeNode* bstToGst(struct TreeNode* root) {\n    int* sum = malloc(sizeof(int));\n    *sum = 0; \n    reverseInorder(root,sum);\n    return root;\n}",
        "tags": [
            "tree",
            "dfs",
            "binary search tree",
            "binary tree"
        ],
        "notes": "learn the actual solution",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Max Sum of a Pair With Equal Sum of Digits",
        "statement": "You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].\n\nReturn the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions. If no such pair of indices exists, return -1.\n\n \n\nExample 1:\n\nInput: nums = [18,43,36,13,7]\nOutput: 54\nExplanation: The pairs (i, j) that satisfy the conditions are:\n- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\nSo the maximum sum that we can obtain is 54.\n\nExample 2:\n\nInput: nums = [10,12,19,14]\nOutput: -1\nExplanation: There are no two numbers that satisfy the conditions, so we return -1.",
        "solution": "class Solution:\n    # Helper function to compute the sum of digits of a number\n    def calculate_digit_sum(self, num):\n        digit_sum = 0\n        while num > 0:\n            digit_sum += num % 10\n            num //= 10\n        return digit_sum\n\n    def maximumSum(self, nums):\n        digit_sum_pairs = []\n\n        # Store numbers with their digit sums as pairs\n        for number in nums:\n            digit_sum = self.calculate_digit_sum(number)\n            digit_sum_pairs.append((digit_sum, number))\n\n        # Sort based on digit sums, and if equal, by number value\n        digit_sum_pairs.sort()\n\n        max_pair_sum = -1\n\n        # Iterate through the sorted array to find the maximum sum of pairs\n        for index in range(1, len(digit_sum_pairs)):\n            current_digit_sum = digit_sum_pairs[index][0]\n            previous_digit_sum = digit_sum_pairs[index - 1][0]\n\n            # If two consecutive numbers have the same digit sum\n            if current_digit_sum == previous_digit_sum:\n                current_sum = (\n                    digit_sum_pairs[index][1] + digit_sum_pairs[index - 1][1]\n                )\n                max_pair_sum = max(max_pair_sum, current_sum)\n\n        return max_pair_sum",
        "tags": [
            "array",
            "hash table",
            "sorting",
            "heap"
        ],
        "notes": "learn this solution",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Minimum Operations to Exceed Threshold Value II",
        "statement": "You are given a 0-indexed integer array nums, and an integer k.\n\nYou are allowed to perform some operations on nums, where in a single operation, you can:\n\n    Select the two smallest integers x and y from nums.\n    Remove x and y from nums.\n    Insert (min(x, y) * 2 + max(x, y)) at any position in the array.\n\nNote that you can only apply the described operation if nums contains at least two elements.\n\nReturn the minimum number of operations needed so that all elements of the array are greater than or equal to k.\n\n \n\nExample 1:\n\nInput: nums = [2,11,10,1,3], k = 10\n\nOutput: 2\n\nExplanation:\n\n    In the first operation, we remove elements 1 and 2, then add 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3].\n    In the second operation, we remove elements 3 and 4, then add 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10].\n\nAt this stage, all the elements of nums are greater than or equal to 10 so we can stop. \n\nIt can be shown that 2 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.\n\nExample 2:\n\nInput: nums = [1,1,2,4,9], k = 20\n\nOutput: 4\n\nExplanation:\n\n    After one operation, nums becomes equal to [2, 4, 9, 3]. \n    After two operations, nums becomes equal to [7, 4, 9]. \n    After three operations, nums becomes equal to [15, 9]. \n    After four operations, nums becomes equal to [33].\n\nAt this stage, all the elements of nums are greater than 20 so we can stop. \n\nIt can be shown that 4 is the minimum number of operations needed so that all elements of the array are greater than or equal to 20.",
        "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        count = 0\n        heapq.heapify(nums)\n        while(len(nums)>=2):\n            min1=heapq.heappop(nums)\n            if(min1<k):\n                count+=1\n                min2 = heapq.heappop(nums)\n                heapq.heappush(nums,min1*2+min2)\n        return count",
        "tags": [
            "array",
            "simulation",
            "heap"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Construct the Lexicographically Largest Valid Sequence",
        "statement": "Given an integer n, find a sequence with elements in the range [1, n] that satisfies all of the following:\n\n    The integer 1 occurs once in the sequence.\n    Each integer between 2 and n occurs twice in the sequence.\n    For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.\n\nThe distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.\n\nReturn the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.\n\nA sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.\n\n \n\nExample 1:\n\nInput: n = 3\nOutput: [3,1,2,3,2]\nExplanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.\n\nExample 2:\n\nInput: n = 5\nOutput: [5,3,1,4,3,5,2,4,2]",
        "solution": "class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n        len_seq = 2 * n - 1 # 1 occurs once, 2-n appear twice\n        seq = [0] * len_seq # init with empty vals\n        used = set() # tracks nums used in seq\n\n        def backtrack(i):\n            if i == len_seq: return True # filled all of sequence\n            if seq[i]: return backtrack(i + 1) # already filled index, check next\n\n            for num in range(n, 0, -1): # try using num at index, n to 1 for lexicographically largest seq\n                if num in used: continue # already used num in sequence\n\n                nxt = i + num if num > 1 else i # second occurance of num, nxt = i if num = 1 so 1 occurance\n\n                if nxt >= len_seq or seq[nxt] != 0: continue # invalid second index\n                \n                seq[i] = seq[nxt] = num # set two occurances of num\n                used.add(num)\n\n                if backtrack(i + 1): # try to fill rest of sequence\n                    return True\n\n                seq[i] = seq[nxt] = 0 # couldn't fill rest, reset seq\n                used.remove(num)\n\n            return False # no num option lead to valid sequence\n\n        backtrack(0) # start backtrack at 0 index\n        return seq",
        "tags": [
            "array",
            "backtracking"
        ],
        "notes": "learn the solutions",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Construct Smallest Number From DI String",
        "statement": "You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.\n\nA 0-indexed string num of length n + 1 is created using the following conditions:\n\n    num consists of the digits '1' to '9', where each digit is used at most once.\n    If pattern[i] == 'I', then num[i] < num[i + 1].\n    If pattern[i] == 'D', then num[i] > num[i + 1].\n\nReturn the lexicographically smallest possible string num that meets the conditions.\n\n \n\nExample 1:\n\nInput: pattern = \"IIIDIDDD\"\nOutput: \"123549876\"\nExplanation:\nAt indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].\nAt indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].\nSome possible values of num are \"245639871\", \"135749862\", and \"123849765\".\nIt can be proven that \"123549876\" is the smallest possible num that meets the conditions.\nNote that \"123414321\" is not possible because the digit '1' is used more than once.\n\nExample 2:\n\nInput: pattern = \"DDD\"\nOutput: \"4321\"\nExplanation:\nSome possible values of num are \"9876\", \"7321\", and \"8742\".\nIt can be proven that \"4321\" is the smallest possible num that meets the conditions.",
        "solution": "class Solution:\n    # Check if the current sequence matches the pattern of 'I' and 'D'\n    def check(self, number_sequence: str, pattern: str) -> bool:\n        for index in range(len(pattern)):\n            # Ensure the sequence is in increasing order at 'I' positions\n            if (\n                pattern[index] == \"I\"\n                and number_sequence[index] > number_sequence[index + 1]\n            ):\n                return False\n            # Ensure the sequence is in decreasing order at 'D' positions\n            elif (\n                pattern[index] == \"D\"\n                and number_sequence[index] < number_sequence[index + 1]\n            ):\n                return False\n        return True\n\n    def smallestNumber(self, pattern: str) -> str:\n        pattern_length = len(pattern)\n\n        # Generate sequence \"123...n+1\"\n        number_sequence = \"\".join(\n            str(num) for num in range(1, pattern_length + 2)\n        )\n\n        # Use permutations generator\n        for permutation in permutations(number_sequence):\n            permutation_str = \"\".join(permutation)\n            if self.check(permutation_str, pattern):\n                return permutation_str\n        return \"\"",
        "tags": [
            "string",
            "backtracking",
            "stack",
            "greedy"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "The k-th Lexicographical String of All Happy Strings of Length n",
        "statement": "A happy string is a string that:\n\n    consists only of letters of the set ['a', 'b', 'c'].\n    s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).\n\nFor example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\n\nGiven two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\n\nReturn the kth string of this list or return an empty string if there are less than k happy strings of length n.\n\n \n\nExample 1:\n\nInput: n = 1, k = 3\nOutput: \"c\"\nExplanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".\n\nExample 2:\n\nInput: n = 1, k = 4\nOutput: \"\"\nExplanation: There are only 3 happy strings of length 1.\n\nExample 3:\n\nInput: n = 3, k = 9\nOutput: \"cab\"\nExplanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"",
        "solution": "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        current_string = \"\"\n        happy_strings = []\n        # Generate all happy strings of length n\n        self.generate_happy_strings(n, current_string, happy_strings)\n\n        # Check if there are at least k happy strings\n        if len(happy_strings) < k:\n            return \"\"\n\n        # Sort the happy strings in lexicographical order\n        happy_strings.sort()\n\n        return happy_strings[k - 1]\n\n    def generate_happy_strings(\n        self, n: int, current_string: str, happy_strings: list\n    ):\n        # If the current string has reached the desired length, add it to the list\n        if len(current_string) == n:\n            happy_strings.append(current_string)\n            return\n\n        # Try adding each character ('a', 'b', 'c') to the current string\n        for current_char in [\"a\", \"b\", \"c\"]:\n            # Skip if the current character is the same as the last character\n            if len(current_string) > 0 and current_string[-1] == current_char:\n                continue\n\n            # Recursively generate the next character\n            self.generate_happy_strings(\n                n, current_string + current_char, happy_strings\n            )",
        "tags": [
            "string",
            "backtracking"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find Unique Binary String",
        "statement": "Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\n\n \n\nExample 1:\n\nInput: nums = [\"01\",\"10\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"00\" would also be correct.\n\nExample 2:\n\nInput: nums = [\"00\",\"01\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"10\" would also be correct.\n\nExample 3:\n\nInput: nums = [\"111\",\"011\",\"001\"]\nOutput: \"101\"\nExplanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.\n",
        "solution": "class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        def generate(curr):\n            if len(curr) == n:\n                if curr not in nums:\n                    return curr\n                \n                return \"\"\n            \n            add_zero = generate(curr + \"0\")\n            if add_zero:\n                return add_zero\n\n            return generate(curr + \"1\")\n\n        n = len(nums)\n        nums = set(nums)\n        return generate(\"\")",
        "tags": [
            "array",
            "hash table",
            "string",
            "backtracking"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Number of Sub-arrays With Odd Sum",
        "statement": "Given an array of integers arr, return the number of subarrays with an odd sum.\n\nSince the answer can be very large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\nInput: arr = [1,3,5]\nOutput: 4\nExplanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]\nAll sub-arrays sum are [1,4,9,3,8,5].\nOdd sums are [1,9,3,5] so the answer is 4.\n\nExample 2:\n\nInput: arr = [2,4,6]\nOutput: 0\nExplanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]\nAll sub-arrays sum are [2,6,12,4,10,6].\nAll sub-arrays have even sum and the answer is 0.\n\nExample 3:\n\nInput: arr = [1,2,3,4,5,6,7]\nOutput: 16",
        "solution": "class Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        MOD = 1e9 + 7\n        n = len(arr)\n\n        # Convert elements to 0 (even) or 1 (odd)\n        for i in range(n):\n            arr[i] %= 2\n\n        # dp_even[i] represents the number of subarrays with an even sum ending\n        # at index i. dp_odd[i] represents the number of subarrays with an odd\n        # sum ending at index i\n        dp_even, dp_odd = [0] * n, [0] * n\n\n        # Initialization based on the last element\n        # The last element is even\n        if arr[n - 1] == 0:\n            dp_even[n - 1] = 1\n        else:\n            # The last element is odd\n            dp_odd[n - 1] = 1\n\n        # Traverse the array in reverse\n        for num in range(n - 2, -1, -1):\n            if arr[num] == 1:\n                # Odd element contributes to odd subarrays\n                dp_odd[num] = (1 + dp_even[num + 1]) % MOD\n                # Even element continues the pattern\n                dp_even[num] = dp_odd[num + 1]\n            else:\n                # Even element contributes to even subarrays\n                dp_even[num] = (1 + dp_even[num + 1]) % MOD\n                # Odd element continues the pattern\n                dp_odd[num] = dp_odd[num + 1]\n\n        # Sum all the odd subarrays\n        count = 0\n        for odd_count in dp_odd:\n            count += odd_count\n            count %= MOD\n\n        return int(count)",
        "tags": [
            "array",
            "math",
            "dynamic programming",
            "prefix sum"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Length of Longest Fibonacci Subsequence",
        "statement": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\n    n >= 3\n    xi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\n\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n\n \n\nExample 1:\n\nInput: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].\n\nExample 2:\n\nInput: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].\n",
        "solution": "class Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        res = 0 \n        arr_set = set(arr)\n        for i in range(len(arr)-1):\n            for j in range(i+1,len(arr)):\n                first = arr[i]\n                second = arr[j]\n                nxt = first + second\n                count = 2\n                while nxt in arr_set:\n                    count +=1\n                    first , second = second ,nxt\n                    nxt = first+second\n                    res = max(res,count)\n        return res",
        "tags": [
            "array",
            "hash table",
            "dynamic programming"
        ],
        "notes": "learn thi",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Check if Number is a Sum of Powers of Three",
        "statement": "Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.\n\nAn integer y is a power of three if there exists an integer x such that y == 3x.\n\n \n\nExample 1:\n\nInput: n = 12\nOutput: true\nExplanation: 12 = 31 + 32\n\nExample 2:\n\nInput: n = 91\nOutput: true\nExplanation: 91 = 30 + 32 + 34\n\nExample 3:\n\nInput: n = 21\nOutput: false\n",
        "solution": "class Solution:\n    def checkPowersOfThree(self, n: int) -> bool:\n        while n > 0:\n            # Check if this power should be used twice\n            if n % 3 == 2:\n                return False\n            # Divide n by 3 to move to the next greater power\n            n //= 3\n        # The ternary representation of n consists only of 0s and 1s\n        return True",
        "tags": [
            "math"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Same Tree",
        "statement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.Example 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false",
        "solution": "class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if(not p and not q):\n            return True\n        if(p and q and p.val ==  q.val):\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        return False",
        "tags": [
            "tree",
            "dfs",
            "bfs",
            "binary tree"
        ],
        "notes": "learn other solution",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Maximum Score After Splitting a String",
        "statement": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\n\nThe score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\n\n \n\nExample 1:\n\nInput: s = \"011101\"\nOutput: 5 \nExplanation: \nAll possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3\n\nExample 2:\n\nInput: s = \"00111\"\nOutput: 5\nExplanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\n\nExample 3:\n\nInput: s = \"1111\"\nOutput: 3",
        "solution": "class Solution:\n    def maxScore(self, s: str) -> int:\n        max = 0\n        for i in range(1,len(s)):    \n            left = s[:i]\n            right = s[i:]\n            count = left.count('0') + right.count('1')\n            if count > max:\n                max = count\n\n        return max",
        "tags": [
            "string",
            "prefix sum"
        ],
        "notes": "learn this",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find Closest Node to Given Two Nodes",
        "statement": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\n\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\n\nYou are also given two integers node1 and node2.\n\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\n\nNote that edges may contain cycles.\n\n \n\nExample 1:\nInput: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\nExample 2:\nInput: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n",
        "solution": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def get_distances(start):\n            dist = [-1] * len(edges)\n            current = start\n            d = 0\n            while current != -1 and dist[current] == -1:\n                dist[current] = d\n                current = edges[current]\n                d += 1\n            return dist\n\n        dist1 = get_distances(node1)\n        dist2 = get_distances(node2)\n\n        min_distance = float('inf')\n        answer = -1\n\n        for i in range(len(edges)):\n            if dist1[i] != -1 and dist2[i] != -1:\n                max_dist = max(dist1[i], dist2[i])\n                if max_dist < min_distance:\n                    min_distance = max_dist\n                    answer = i\n                elif max_dist == min_distance and i < answer:\n                    answer = i\n\n        return answer",
        "tags": [
            "dfs",
            "graph"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Distribute Candies Among Children II",
        "statement": "You are given two positive integers n and limit.\n\nReturn the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.\n\n \n\nExample 1:\n\nInput: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\nExample 2:\n\nInput: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).",
        "solution": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        total = 0\n        for i in range(min(n, limit) + 1):\n            min_j = max(0, n - i - limit)\n            max_j = min(limit, n - i)\n            if min_j <= max_j:\n                total += (max_j - min_j + 1)\n        return total",
        "tags": [
            "math",
            "combinatorics",
            "enumeration"
        ],
        "notes": "learn this",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "statement": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.\n\nGiven an integer n, return a list of two integers [a, b] where:\n\n    a and b are No-Zero integers.\n    a + b = n\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: [1,1]\nExplanation: Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.\n\nExample 2:\n\nInput: n = 11\nOutput: [2,9]\nExplanation: Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 11 = n.\nNote that there are other valid answers as [8, 3] that can be accepted.",
        "solution": "class Solution {\n    public int[] getNoZeroIntegers(int n) {\n        int []res = new int[2];\n        for (int i=1;i<n;i++){\n            if(!String.valueOf(i).contains(\"0\") && !String.valueOf(n-i).contains(\"0\")){\n                res[0] = i;\n                res[1] = n-i;\n            }\n        }   \n        return res;\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "learn this",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Count Hills and Valleys in an Array",
        "statement": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\n\nReturn the number of hills and valleys in nums.\n\n \n\nExample 1:\n\nInput: nums = [2,4,1,1,6,5]\nOutput: 3\nExplanation:\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\nExample 2:\n\nInput: nums = [6,6,5,5,4,1]\nOutput: 0\nExplanation:\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n",
        "solution": "class Solution {\n    public int countHillValley(int[] nums) {\n        int count = 0;\n        for (int i = 1; i < nums.length - 1; i++) {\n            int num = nums[i];\n            int left = i - 1, right = i + 1;\n            if (nums[i - 1] == nums[i]) {\n                continue;\n            }\n            for (int m = i - 1; m >= 0; m--) {\n                if (nums[m] != num) {\n                    left = m;\n                    break;\n                }\n            }\n            for (int m = i + 1; m < nums.length ; m++) {\n                if (nums[m] != num) {\n                    right = m;\n                    break;\n                }\n            }\n\n            if (num > nums[left] && num > nums[right]) {\n                count++;\n            }\n            if (num < nums[left] && num < nums[right]) {\n                count++;\n            }\n\n        }\n        return count;\n    }\n}",
        "tags": [
            "array"
        ],
        "notes": "learn this",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Left and Right Sum Differences",
        "statement": "You are given a 0-indexed integer array nums of size n.\n\nDefine two arrays leftSum and rightSum where:\n\n    leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.\n    rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.\n\nReturn an integer array answer of size n where answer[i] = |leftSum[i] - rightSum[i]|.\n\n \n\nExample 1:\n\nInput: nums = [10,4,8,3]\nOutput: [15,1,11,22]\nExplanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].\nThe array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].\n\nExample 2:\n\nInput: nums = [1]\nOutput: [0]\nExplanation: The array leftSum is [0] and the array rightSum is [0].\nThe array answer is [|0 - 0|] = [0].",
        "solution": "class Solution {\n    public int[] leftRightDifference(int[] nums) {\n        int leftSum[] = new int[nums.length];\n        int rightSum[] = new int[nums.length];\n        int Sum[] = new int[nums.length];\n        for(int i=0;i<nums.length-1;i++){\n            for(int j=i+1;j<nums.length;j++){\n                rightSum[i] += nums[j];\n            }\n        }\n        for(int i=nums.length-1;i>0;i--){\n            for(int j=i-1;j>=0;j--){\n                leftSum[i] += nums[j];\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            Sum[i] = Math.abs(leftSum[i] - rightSum[i]);\n        }\n        System.gc();\n        return Sum;\n    }\n}",
        "tags": [
            "array",
            "prefix sum"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Divisible and Non-divisible Sums Difference",
        "statement": "You are given positive integers n and m.\n\nDefine two integers as follows:\n\n    num1: The sum of all integers in the range [1, n] (both inclusive) that are not divisible by m.\n    num2: The sum of all integers in the range [1, n] (both inclusive) that are divisible by m.\n\nReturn the integer num1 - num2.\n\n \n\nExample 1:\n\nInput: n = 10, m = 3\nOutput: 19\nExplanation: In the given example:\n- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.\n- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.\nWe return 37 - 18 = 19 as the answer.\n\nExample 2:\n\nInput: n = 5, m = 6\nOutput: 15\nExplanation: In the given example:\n- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.\n- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.\nWe return 15 - 0 = 15 as the answer.\n\nExample 3:\n\nInput: n = 5, m = 1\nOutput: -15\nExplanation: In the given example:\n- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.\n- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.\nWe return 0 - 15 = -15 as the answer.\n",
        "solution": "class Solution {\n    public int differenceOfSums(int n, int m) {\n        int num1=0,num2=0;\n        for(int i = 1;i<=n;i++){\n            if(i%m!=0){\n                num1 += i;\n                continue;\n            }\n            // num2 += i;\n        }\n        num2=(n*(n+1))/2;\n        return num1-(num2-num1);\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find the Maximum Achievable Number",
        "statement": "Given two integers, num and t. A number x is achievable if it can become equal to num after applying the following operation at most t times:\n\n    Increase or decrease x by 1, and simultaneously increase or decrease num by 1.\n\nReturn the maximum possible value of x.\n\n \n\nExample 1:\n\nInput: num = 4, t = 1\n\nOutput: 6\n\nExplanation:\n\nApply the following operation once to make the maximum achievable number equal to num:\n\n    Decrease the maximum achievable number by 1, and increase num by 1.\n\nExample 2:\n\nInput: num = 3, t = 2\n\nOutput: 7\n\nExplanation:\n\nApply the following operation twice to make the maximum achievable number equal to num:\n\n    Decrease the maximum achievable number by 1, and increase num by 1.\n",
        "solution": "class Solution {\n    public int theMaximumAchievableX(int num, int t) {\n        return num + (2 * t);\n    }\n}",
        "tags": [
            "math"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Spiral Matrix",
        "statement": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\n \n\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
        "solution": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<>();\n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n\n        while (top <= bottom && left <= right) {\n            // Top row\n            for (int i = left; i <= right; i++) {\n                res.add(matrix[top][i]);\n            }\n            top++;\n\n            // Right column\n            for (int i = top; i <= bottom; i++) {\n                res.add(matrix[i][right]);\n            }\n            right--;\n\n            if (top <= bottom) {\n                // Bottom row\n                for (int i = right; i >= left; i--) {\n                    res.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n\n            if (left <= right) {\n                // Left column\n                for (int i = bottom; i >= top; i--) {\n                    res.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        return res;\n    }\n}",
        "tags": [
            "array",
            "matrix",
            "simulation"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Valid Anagram",
        "statement": "Given two strings s and t, return true if t is an\n\nof s, and false otherwise.\n\n \n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\n\nOutput: false",
        "solution": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        char[] a = s.toCharArray();\n        char[] b = t.toCharArray();\n        Arrays.sort(a);\n        Arrays.sort(b);\n        int i=0;\n        while(i<a.length){\n            if(a[i]!=b[i]){\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n}",
        "tags": [
            "hash table",
            "string",
            "sorting"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Longest Consecutive Sequence",
        "statement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\n \n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\nExample 3:\n\nInput: nums = [1,0,1,2]\nOutput: 3",
        "solution": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length==0){return 0;}\n        TreeSet<Integer> hash = new TreeSet<>();\n        for(int i:nums){\n            hash.add(i);\n        }\n        ArrayList<Integer> list = new ArrayList<>(hash);\n        int streak=1,max=1;\n        for(int val=1;val<list.size();val++){\n            if((list.get(val)-list.get(val-1))==1){\n                streak+=1;\n            }else{\n                max=Math.max(streak,max);\n                streak=1;\n            }\n        }\n        return Math.max(streak, max);\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "union find"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Set Matrix Zeroes",
        "statement": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place.\n\n \n\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n",
        "solution": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int row = matrix.length, col = matrix[0].length;\n        for(int i = 0 ; i < row;i++){\n            for(int j = 0 ; j < col ; j++){\n                if(matrix[i][j]==0){\n                    makeZero(matrix,i,j,-11);\n                }\n            }\n        }\n        for(int i = 0 ; i < row;i++){\n            for(int j = 0 ; j < col ; j++){\n                if(matrix[i][j]==-11){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n    }\n    public static void makeZero(int[][] matrix,int row,int col,int val){\n        for(int i = 0;i<matrix[row].length;i++){\n            if(matrix[row][i]!=0){\n                matrix[row][i] = val;\n            }\n        }\n        for(int i = 0;i<matrix.length;i++){\n            if(matrix[i][col]!=0){\n                matrix[i][col] = val;\n            }\n        }\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "matrix"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Number of Zero-Filled Subarrays",
        "statement": "Given an integer array nums, return the number of subarrays filled with 0.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n \n\nExample 1:\n\nInput: nums = [1,3,0,0,2,0,0,4]\nOutput: 6\nExplanation: \nThere are 4 occurrences of [0] as a subarray.\nThere are 2 occurrences of [0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.\n\nExample 2:\n\nInput: nums = [0,0,0,2,0,0]\nOutput: 9\nExplanation:\nThere are 5 occurrences of [0] as a subarray.\nThere are 3 occurrences of [0,0] as a subarray.\nThere is 1 occurrence of [0,0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\n\nExample 3:\n\nInput: nums = [2,10,2019]\nOutput: 0\nExplanation: There is no subarray filled with 0. Therefore, we return 0.\n",
        "solution": "class Solution {\n    \n    public long zeroFilledSubarray(int[] nums) {\n        long count = 0;\n        long contiguous = 0;\n        for(int num:nums){\n            if(num == 0){\n                contiguous+=1;\n                count+=contiguous;\n            }else{\n                contiguous=0;\n            }\n        }\n        return count;\n    }\n}",
        "tags": [
            "array",
            "math"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find All Duplicates in an Array",
        "statement": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that appears twice.\n\nYou must write an algorithm that runs in O(n) time and uses only constant auxiliary space, excluding the space needed to store the output\n\n \n\nExample 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\n\nExample 2:\n\nInput: nums = [1,1,2]\nOutput: [1]\n\nExample 3:\n\nInput: nums = [1]\nOutput: []",
        "solution": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        ArrayList<Integer> list = new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            int idx = Math.abs(nums[i]) - 1;\n            if(nums[idx]<0){\n                list.add(Math.abs(nums[i]));\n            }else{\n                nums[idx] = -nums[idx];\n            }\n        }\n        return list;\n    }\n}",
        "tags": [
            "array",
            "hash table"
        ],
        "notes": "learn in place marking",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Increasing Triplet Subsequence",
        "statement": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\n\nExample 2:\n\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\n\nExample 3:\n\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: One of the valid triplet is (3, 4, 5), because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.",
        "solution": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int first = Integer.MAX_VALUE;\n        int second = Integer.MAX_VALUE;\n        for(int val:nums){\n            if(val<=first){\n                first=val;\n            }else if(val<=second){\n                second = val;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "tags": [
            "array",
            "greedy"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Convert 1D Array Into 2D Array",
        "statement": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\n\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\n\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n\n \n\nExample 1:\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\nExample 2:\n\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n\nExample 3:\n\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.",
        "solution": "class Solution {\n    public int[][] construct2DArray(int[] original, int m, int n) {\n        if (original.length != m*n)return new int[0][0];\n        int [][] res = new int[m][n]; \n        int idx=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                res[i][j] = original[idx++];\n            }\n        }\n        return res;\n    }\n}",
        "tags": [
            "array",
            "matrix",
            "simulation"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Power of Four",
        "statement": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is a power of four, if there exists an integer x such that n == 4x.\n\n \n\nExample 1:\n\nInput: n = 16\nOutput: true\n\nExample 2:\n\nInput: n = 5\nOutput: false\n\nExample 3:\n\nInput: n = 1\nOutput: true\n\n ENd",
        "solution": "class Solution {\n    public boolean isPowerOfFour(int n) {\n        if(n<=0){\n            return false;\n        }\n        for(int i = 0;i<=31;i=i+2){\n            if((1<<i) == n){\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "notes": "",
        "difficulty": "Easy",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Find the Prefix Common Array of Two Arrays",
        "statement": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\n\n \n\nExample 1:\n\nInput: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n\nExample 2:\n\nInput: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.",
        "solution": "class Solution {\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\n        int [] frequency = new int[A.length+1];\n        int i=0,n=A.length,count=0;\n        int [] res = new int[n];\n        while(i<n){\n            frequency[A[i]]++;\n            if(frequency[A[i]] == 2 ){\n                count+=1;\n            }\n            frequency[B[i]]++;\n            if(frequency[B[i]] == 2){\n                count+=1;\n            }\n            res[i]=count;\n            i++;\n        }\n        return res;\n    }\n}",
        "tags": [
            "array",
            "hash table",
            "bit manipulation"
        ],
        "notes": "",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    },
    {
        "title": "Longest Subarray with Sum K",
        "statement": "Given an array arr[] containing integers and an integer k, your task is to find the length of the longest subarray where the sum of its elements is equal to the given value k. If there is no subarray with sum equal to k, return 0.\n\nExamples:\n\nInput: arr[] = [10, 5, 2, 7, 1, -10], k = 15\nOutput: 6\nExplanation: Subarrays with sum = 15 are [5, 2, 7, 1], [10, 5] and [10, 5, 2, 7, 1, -10]. The length of the longest subarray with a sum of 15 is 6.\n\nInput: arr[] = [-5, 8, -14, 2, 4, 12], k = -5\nOutput: 5\nExplanation: Only subarray with sum = -5 is [-5, 8, -14, 2, 4] of length 5.\n\nInput: arr[] = [10, -10, 20, 30], k = 5\nOutput: 0\nExplanation: No subarray with sum = 5 is present in arr[].",
        "solution": "import java.util.*;\n\npublic class Main {\n    public static int getLongestSubarray(int []a, long k) {\n        int n = a.length; // size of the array.\n\n        int left = 0, right = 0; // 2 pointers\n        long sum = a[0];\n        int maxLen = 0;\n        while (right < n) {\n            // if sum > k, reduce the subarray from left\n            // until sum becomes less or equal to k:\n            while (left <= right && sum > k) {\n                sum -= a[left];\n                left++;\n            }\n\n            // if sum = k, update the maxLen i.e. answer:\n            if (sum == k) {\n                maxLen = Math.max(maxLen, right - left + 1);\n            }\n\n            // Move forward thw right pointer:\n            right++;\n            if (right < n) sum += a[right];\n        }\n\n        return maxLen;\n    }\n\n",
        "tags": [
            "array",
            "hashmap",
            "prefix sum",
            "two pointers"
        ],
        "notes": "this solution is using prefix sum , sliding / two pointer does not work for negative numbers",
        "difficulty": "Medium",
        "last_reviewed": null,
        "next_review": null,
        "review_count": 0,
        "success_count": 0,
        "ef": 2.5,
        "interval": 1
    }
]